#ifndef CBACKEND_H
#define CBACKEND_H

#include <map>
#include <string>
#include <sstream>
#include <iostream>
#include <iomanip>
#include "../DataStructures.h"

// C Backend. Generates C89-compliant code
class CBackend
{
	std::wstring name;
	std::map<std::wstring, FormatDesc> formats;

	std::map<std::wstring, std::wstring> basicTypeMap;

	std::wstring ToUpper(std::wstring str)
	{
		std::transform(str.begin(), str.end(), str.begin(), ::toupper);
		return str;
	}

	std::wstring GenErrorOutputParam()
	{
		return L"int* out_error";
	}

	std::wstring CTypeName(std::wstring originalTypeName)
	{
		auto entry = basicTypeMap.find(originalTypeName);
		if (entry == basicTypeMap.end())
		{
			return originalTypeName;
		}
		return entry->second;
	}

	std::wstring GetMemberContainingArrayElementCount(const FormatMember& member)
	{
		std::wstring str = member.GetMemberContainingArraySize();
		if (str.length() == 0)
		{
			return L"COUNT_" + member.GetName();
		}
		return str;
	}

	std::wstring GetMemberContainingArrayCapacity(const FormatMember& member)
	{
		return L"CAPACITY_" + member.GetName();
	}

	std::wstring GenerateCTypeForAllocation(const FormatMember& member)
	{
		std::wstringstream ss;

		ss << CTypeName(member.GetTypeName());

		if (!member.HasBasicType())
		{
			ss << "*";
		}

		return ss.str();
	}

	std::wstring GenerateCTypeForDeclaration(const FormatMember& member)
	{
		std::wstringstream ss;

		ss << GenerateCTypeForAllocation(member);

		if (member.IsArray())
		{
			ss << "*";
		}

		return ss.str();
	}

	std::wstring padTo(const size_t num, const wchar_t paddingChar = L' ')
	{
		std::wstring str;
		str.insert(0, num - str.size(), paddingChar);
		return str;
	}

	void GenerateStructPrototype()
	{
		std::wcout << "/**" << std::endl;
		std::wcout << " * Opaque struct prototypes generated by serialist" << std::endl;
		std::wcout << " **/" << std::endl;

		for (auto kvpair : formats)
		{
			FormatDesc& desc = kvpair.second;
			std::wcout << "typedef struct _tag_" << kvpair.first << " " << kvpair.first << ";" << std::endl;
		}

		std::wcout << std::endl;
	}

	void GenerateStructDefinition()
	{
		std::wstring sizetypename = L"size_t";

		for (auto kvpair : formats)
		{
			FormatDesc& desc = kvpair.second;
			std::wcout << "struct _tag_" << kvpair.first << " {" << std::endl;

			int columnSize = 0;
			desc.ForeachMember([&](FormatMember& member)
			{
				auto size = GenerateCTypeForDeclaration(member).length();

				if (member.IsArray() && size < sizetypename.length())
				{
					size = sizetypename.length();
				}

				if (size > columnSize)
				{
					columnSize = size;
				}

			});
			columnSize++;

			desc.ForeachMember([&](FormatMember& member)
			{
				auto typeName = GenerateCTypeForDeclaration(member);

				std::wcout << "\t" << typeName << padTo(columnSize - typeName.length()) << member.GetName() << ";" << std::endl;

				if (member.IsLengthOnlyKnownAtRuntime())
				{
					if (!member.HasMemberContainingArraySize())
					{
						std::wcout << "\t" << sizetypename << padTo(columnSize - sizetypename.length()) << GetMemberContainingArrayElementCount(member) << ";" << std::endl;
					}
					std::wcout << "\t" << sizetypename << padTo(columnSize - sizetypename.length()) << GetMemberContainingArrayCapacity(member) << ";" << std::endl;
				}
			});

			std::wcout << "};" << std::endl << std::endl;
		}
	}

	std::wstring GenerateCreatePrototypeSignature(std::wstring formatName)
	{
		std::wstringstream ss;
		ss << formatName << "* Create" << formatName << "()";
		return ss.str();
	}


	void GenerateDeleteDefinitionForMember(FormatMember member, int indent = 0)
	{
		if (member.IsArray())
		{
			std::wstringstream initialSize;
			if (!member.IsLengthOnlyKnownAtRuntime())
			{
				initialSize << member.GetFixedArraySize();
			}
			else
			{
				initialSize << "object->" << GetMemberContainingArrayElementCount(member);
			}

			if (!member.HasBasicType())
			{
				std::wcout << padTo(indent, '\t') << "for (i=0; i<" << initialSize.str() << "; i++)" << std::endl;
				std::wcout << padTo(indent, '\t') << "{" << std::endl;
				std::wcout << padTo(indent+1, '\t') << "Delete" << member.GetTypeName() << "(&object->" << member.GetName() << "[i]);" << std::endl;
				std::wcout << padTo(indent, '\t') << "}" << std::endl;
			}

			std::wcout << padTo(indent, '\t') << "free(object->" << member.GetName() << ");" << std::endl;

		}
		else if (!member.HasBasicType())
		{
			std::wcout << padTo(indent, '\t') << "free(object->" << member.GetName() << ");" << std::endl;
		}
	}

	void GenerateErrorCaseDeallocator(std::vector<FormatMember>& membersInitialized, FormatMember& member, int indent = 0, bool arrayMember = false)
	{
		std::wcout << padTo(indent, '\t') << "if (object->" << member.GetName();
		if (arrayMember)
		{
			std::wcout << "[i]";
		}
		std::wcout << " == NULL)" << std::endl;
		std::wcout << padTo(indent, '\t') << "{" << std::endl;
		std::wcout << padTo(indent+1, '\t') << "/* Allocation of " << member.GetName() << " fails, deallocate allocations so far and return NULL */" << std::endl;

		if (arrayMember)
		{
			membersInitialized.push_back(member);
		}

		for (int i=membersInitialized.size()-1; i>=0 ;i--)
		{
			GenerateDeleteDefinitionForMember(membersInitialized[i], indent+1);
		}

		std::wcout << padTo(indent+1, '\t') << "free(object);" << std::endl;
		std::wcout << padTo(indent+1, '\t') << "return NULL;" << std::endl;
		std::wcout << padTo(indent, '\t') << "}" << std::endl;
	
	}

	void GenerateCreateFunction(FormatDesc& desc, bool prototype)
	{
		std::wcout << GenerateCreatePrototypeSignature(desc.GetName());
		if (prototype)
		{
			std::wcout << ";" << std::endl;
		}
		else
		{
			std::wcout << std::endl << "{" << std::endl;
			if (!desc.IsTrivial())
			{
				std::wcout << "\tsize_t i = 0;" << std::endl;
			}
			std::wcout << "\t" << desc.GetName() << "* object = calloc(1, sizeof(" << desc.GetName() << "));" << std::endl;

			std::vector<FormatMember> membersInitialized;
			desc.ForeachMember([&](FormatMember& member)
			{
				if (member.IsArray())
				{
					int initialSize = 0;
					if (!member.IsLengthOnlyKnownAtRuntime())
					{
						initialSize = member.GetFixedArraySize();
					}

					if (initialSize != 0)
					{
						std::wcout << "\tobject->" << member.GetName() << " = calloc(" << initialSize << ", sizeof(" << GenerateCTypeForAllocation(member) << ")" << ");" << std::endl;

						GenerateErrorCaseDeallocator(membersInitialized, member, 1);

						if (!member.HasBasicType())
						{
							std::wcout << "\tfor (i=0; i<" << initialSize << "; i++)" << std::endl;
							std::wcout << "\t{" << std::endl;
							std::wcout << "\t\tobject->" << member.GetName() << "[i] = Create" << member.GetTypeName() << "();" << std::endl;

							GenerateErrorCaseDeallocator(membersInitialized, member, 2, true);

							std::wcout << "\t}" << std::endl;
						}
					}
				}
				else if (!member.HasBasicType())
				{
					std::wcout << "\tobject->" << member.GetName() << " = Create" << member.GetTypeName() << "();" << std::endl;

					GenerateErrorCaseDeallocator(membersInitialized, member, 1);
				}
				membersInitialized.push_back(member);
			});

			std::wcout << "\treturn object;" << std::endl;
			std::wcout << "}" << std::endl;
		}
	}

	void GenerateCreatePrototype()
	{
		for (auto kvpair : formats)
		{
			FormatDesc& desc = kvpair.second;

			std::wcout << "/**" << std::endl;
			std::wcout << " * Creates a " << desc.GetName() << " object and returns a pointer to it." << std::endl;
			std::wcout << " * This function will initialize all members except pointers for arrays with known sizes to zero." << std::endl;
			std::wcout << " **/" << std::endl;
			GenerateCreateFunction(desc, true);
			std::wcout << std::endl;
		}
	}

	void GenerateCreateDefinition()
	{
		for (auto kvpair : formats)
		{
			FormatDesc& desc = kvpair.second;
			GenerateCreateFunction(desc, false);
			std::wcout << std::endl;
		}
	}

	void GenerateDeleteFunction(FormatDesc& desc, bool prototype)
	{
		std::wcout << "void Delete" << desc.GetName() << "(" << desc.GetName() << "** ref_object)";
		if (prototype)
		{
			std::wcout << ";" << std::endl;
		}
		else
		{
			std::wcout << std::endl;
			std::wcout << "{" << std::endl;
			if (!desc.IsTrivial())
			{
				std::wcout << "\tsize_t i = 0;" << std::endl;
			}
			std::wcout << "\t" << desc.GetName() << "* object;" << std::endl;

			std::wcout << "\tif (ref_object == NULL || *ref_object == NULL) { return; }" << std::endl;
			std::wcout << "\tobject = *ref_object;" << std::endl;

			desc.ForeachMemberBackwards([&](FormatMember& member)
			{
				GenerateDeleteDefinitionForMember(member, 1);
			});

			std::wcout << "\tfree(object);" << std::endl;
			std::wcout << "\t*ref_object = NULL;" << std::endl;

			std::wcout << "}" << std::endl;
		}
	}

	void GenerateDeletePrototype()
	{
		for (auto kvpair : formats)
		{
			FormatDesc& desc = kvpair.second;

			std::wcout << "/**" << std::endl;
			std::wcout << " * Deletes a " << desc.GetName() << " object and sets its pointer to NULL" << std::endl;
			std::wcout << " **/" << std::endl;
			GenerateDeleteFunction(desc, true);

			std::wcout << std::endl;
		}
	}

	void GenerateDeleteDefinition()
	{
		for (auto kvpair : formats)
		{
			FormatDesc& desc = kvpair.second;
			GenerateDeleteFunction(desc, false);

			std::wcout << std::endl;
		}
	}

	void GenerateWriteFunction(FormatDesc& desc, bool prototype)
	{
		std::wcout << "void Write" << desc.GetName() << "(" << desc.GetName() << "* object, unsigned char** out_bytes, size_t* out_length, " << GenErrorOutputParam() << ")";
		if (prototype)
		{
			std::wcout << ";" << std::endl;
		}
		else
		{
			std::wcout << std::endl;
			std::wcout << "{" << std::endl;

			desc.ForeachMember([&](FormatMember& member)
			{

			});

			std::wcout << "}" << std::endl;
		}
	}

	void GenerateWritePrototype()
	{
		for (auto kvpair : formats)
		{
			FormatDesc& desc = kvpair.second;

			std::wcout << "/**" << std::endl;
			std::wcout << " * Allocates a byte array and serializes an existing " << desc.GetName() << " object to it." << std::endl;
			std::wcout << " **/" << std::endl;
			GenerateWriteFunction(desc, true);
			
			std::wcout << std::endl;
		}
	}

	void GenerateWriteDefinition()
	{
		for (auto kvpair : formats)
		{
			FormatDesc& desc = kvpair.second;
			GenerateWriteFunction(desc, false);

			std::wcout << std::endl;
		}
	}

	void GenerateReadFunction(FormatDesc& desc, bool prototype)
	{
		std::wcout << desc.GetName() << "* Read" << desc.GetName() << "(" << "unsigned char* bytes, size_t length, " << GenErrorOutputParam() << ")";
		if (prototype)
		{
			std::wcout << ";" << std::endl;
		}
		else
		{
			std::wcout << std::endl;
			std::wcout << "{" << std::endl;

			std::wcout << "\t" << desc.GetName() << "* object = Create" << desc.GetName() << "();" << std::endl;

			desc.ForeachMember([&](FormatMember& member)
			{
			});

			std::wcout << "\treturn object;" << std::endl;

			std::wcout << "}" << std::endl;
		}
	}

	void GenerateReadPrototype()
	{
		for (auto kvpair : formats)
		{
			FormatDesc& desc = kvpair.second;

			std::wcout << "/**" << std::endl;
			std::wcout << " * Allocates and deserializes a " << desc.GetName() << " from a byte array, and returns a pointer to it." << std::endl;
			std::wcout << " **/" << std::endl;
			GenerateReadFunction(desc, true);

			std::wcout << std::endl;
		}
	}

	void GenerateReadDefinition()
	{
		for (auto kvpair : formats)
		{
			FormatDesc& desc = kvpair.second;

			GenerateReadFunction(desc, false);

			std::wcout << std::endl;
		}
	}

	void GenerateObjectPresenceCheck(int indent, bool basicType)
	{
		std::wstring defaultReturn = L"NULL";
		if (basicType)
		{
			defaultReturn = L"0";
		}

		std::wcout << padTo(indent, '\t') << "if (out_error != NULL) { *out_error = NO_ERROR; }" << std::endl;

		std::wcout << padTo(indent, '\t') << "if (object == NULL)" << std::endl;
		std::wcout << padTo(indent, '\t') << "{" << std::endl;

		std::wcout << padTo(indent+1, '\t') << "if (out_error != NULL) { *out_error = NULL_OBJECT; }" << std::endl;

		std::wcout << padTo(indent+1, '\t') << "return " << defaultReturn << ";" << std::endl;

		std::wcout << padTo(indent, '\t') << "}" << std::endl;
	}

	void GenerateArrayIndexCheck(int indent, const FormatMember& member)
	{
		std::wstring defaultReturn = L"NULL";
		if (member.HasBasicType())
		{
			defaultReturn = L"0";
		}

		if (member.IsLengthOnlyKnownAtRuntime())
		{
			std::wcout << padTo(indent, '\t') << "if (index >= object->" << GetMemberContainingArrayElementCount(member) << ")" << std::endl;
		}
		else
		{
			std::wcout << padTo(indent, '\t') << "if (index >= " << member.GetFixedArraySize() << ")" << std::endl;
		}
		std::wcout << padTo(indent, '\t') << "{" << std::endl;
		std::wcout << padTo(indent+1, '\t') << "if (out_error != NULL) { *out_error = INDEX_OUT_OF_BOUNDS; }" << std::endl;
		std::wcout << padTo(indent+1, '\t') << "return " << defaultReturn << ";" << std::endl;
		std::wcout << padTo(indent, '\t') << "}" << std::endl;
	}

	void GenerateGetArrayAccessorFunction(FormatDesc& desc, FormatMember& member, bool prototype)
	{
		std::wcout << GenerateCTypeForAllocation(member) << " Get" << desc.GetName() << "_" << member.GetName() << "(" << desc.GetName() << "* object, size_t index, " << GenErrorOutputParam() << ")";
		if (prototype)
		{
			std::wcout << ";" << std::endl;
		}
		else
		{
			std::wcout << std::endl;
			std::wcout << "{" << std::endl;

			GenerateObjectPresenceCheck(1, member.HasBasicType());
			GenerateArrayIndexCheck(1, member);

			std::wcout << "\treturn object->" << member.GetName() << "[index];" << std::endl;

			std::wcout << "}" << std::endl;
		}
	}

	void GenerateGetArrayCountFunction(FormatDesc& desc, FormatMember& member, bool prototype)
	{
		std::wcout << "size_t GetNumberOf" << desc.GetName() << "_" << member.GetName() << "(" << desc.GetName() << "* object, " << GenErrorOutputParam() << ")";
		if (prototype)
		{
			std::wcout << ";" << std::endl;
		}
		else
		{
			std::wcout << std::endl;
			std::wcout << "{" << std::endl;

			GenerateObjectPresenceCheck(1, true);

			if (member.IsLengthOnlyKnownAtRuntime())
			{
				std::wcout << "\treturn object->" << GetMemberContainingArrayElementCount(member) << ";" << std::endl;
			}
			else
			{
				std::wcout << "\treturn " << member.GetFixedArraySize() << ";" << std::endl;
			}

			std::wcout << "}" << std::endl;
		}
	}

	void GenerateGetAccessorFunction(FormatDesc& desc, FormatMember& member, bool prototype)
	{
		std::wcout << GenerateCTypeForAllocation(member) << " Get" << desc.GetName() << "_" << member.GetName() << "(" << desc.GetName() << "* object, " << GenErrorOutputParam() << ")";
		if (prototype)
		{
			std::wcout << ";" << std::endl;
		}
		else
		{
			std::wcout << std::endl;
			std::wcout << "{" << std::endl;

			GenerateObjectPresenceCheck(1, member.HasBasicType());

			std::wcout << "\treturn object->" << member.GetName() << ";" << std::endl;
			
			std::wcout << "}" << std::endl;
		}
	}

	void GenerateGetAccessorPrototype()
	{
		for (auto kvpair : formats)
		{
			FormatDesc& desc = kvpair.second;

			std::wcout << "/**" << std::endl;
			std::wcout << " * Get accessors for the struct " << desc.GetName() << std::endl;
			std::wcout << " **/" << std::endl;

			desc.ForeachMember([&](FormatMember& member)
			{
				if (member.IsArray())
				{
					GenerateGetArrayAccessorFunction(desc, member, true);
					GenerateGetArrayCountFunction(desc, member, true);
				}
				else
				{
					GenerateGetAccessorFunction(desc, member, true);
				}
			});

			std::wcout << std::endl;
		}
	}

	void GenerateGetAccessorDefinition()
	{
		for (auto kvpair : formats)
		{
			FormatDesc& desc = kvpair.second;

			desc.ForeachMember([&](FormatMember& member)
			{
				if (member.IsArray())
				{
					GenerateGetArrayAccessorFunction(desc, member, false);
					std::wcout << std::endl;
					GenerateGetArrayCountFunction(desc, member, false);
				}
				else
				{
					GenerateGetAccessorFunction(desc, member, false);
				}
				std::wcout << std::endl;
			});

		}
	}

	void GenerateSetAccessorPrototype()
	{
		for (auto kvpair : formats)
		{
			FormatDesc& desc = kvpair.second;

			std::wcout << "/**" << std::endl;
			std::wcout << " * Set accessors for the struct " << desc.GetName() << std::endl;
			std::wcout << " **/" << std::endl;

			desc.ForeachMember([&](FormatMember& member)
			{
				if (member.IsArray())
				{
					std::wcout << "void Set" << desc.GetName() << "_" << member.GetName() << "(" << desc.GetName() << "* in_object, size_t index, " << GenerateCTypeForAllocation(member) << " in_member, " << GenErrorOutputParam() << ");" << std::endl;

					if (member.IsLengthOnlyKnownAtRuntime())
					{
						std::wcout << "void AddTo" << desc.GetName() << "_" << member.GetName() << "(" << desc.GetName() << "* in_object, size_t index, " << GenerateCTypeForAllocation(member) << " in_member, " << GenErrorOutputParam() << ");" << std::endl;
						std::wcout << "void RemoveFrom" << desc.GetName() << "_" << member.GetName() << "(" << desc.GetName() << "* in_object, size_t index, " << GenErrorOutputParam() << ");" << std::endl;
					}
				}
				else
				{
					std::wcout << "void Set" << desc.GetName() << "_" << member.GetName() << "(" << desc.GetName() << "* in_object, " << GenerateCTypeForAllocation(member) << " in_member, " << GenErrorOutputParam() << ");" << std::endl;
				}
			});

			std::wcout << std::endl;
		}
	}

	void GenerateSetAccessorDefinition()
	{
		for (auto kvpair : formats)
		{
			FormatDesc& desc = kvpair.second;

			desc.ForeachMember([&](FormatMember& member)
			{

			});
		}
	}

public:
	CBackend(std::wstring name, std::map<std::wstring, FormatDesc> formats) : name(name), formats(formats)
	{
		basicTypeMap[L"Uint8"] = L"unsigned char";
		basicTypeMap[L"Uint16"] = L"unsigned short";
		basicTypeMap[L"Uint32"] = L"unsigned int";
		basicTypeMap[L"Uint64"] = L"unsigned long long";
		basicTypeMap[L"Int8"] = L"signed char";
		basicTypeMap[L"Int16"] = L"short";
		basicTypeMap[L"Int32"] = L"int";
		basicTypeMap[L"Int64"] = L"long long";
		basicTypeMap[L"Float32"] = L"float";
		basicTypeMap[L"Float64"] = L"double";
	}

	void GenerateHeader()
	{
		std::wstring headerDefine = ToUpper(name) + L"_H";
		std::wcout << "#ifndef " << headerDefine << std::endl;
		std::wcout << "#define " << headerDefine << std::endl << std::endl;

		std::wcout << "#ifndef _SERIALIST_DEFINES_" << std::endl;
		std::wcout << "#define _SERIALIST_DEFINES_" << std::endl;
		std::wcout << "#define NO_ERROR            0" << std::endl;
		std::wcout << "#define NULL_OBJECT         1" << std::endl;
		std::wcout << "#define ALLOC_FAILED        2" << std::endl;
		std::wcout << "#define INDEX_OUT_OF_BOUNDS 3" << std::endl;

		std::wcout << "#endif // _SERIALIST_DEFINES_" << std::endl << std::endl;

		std::wcout << "#ifdef __cplusplus" << std::endl;
		std::wcout << "extern \"C\" {" << std::endl;
		std::wcout << "#endif" << std::endl << std::endl;

		GenerateStructPrototype();
		GenerateCreatePrototype();
		GenerateDeletePrototype();
		GenerateWritePrototype();
		GenerateReadPrototype();
		GenerateGetAccessorPrototype();
		GenerateSetAccessorPrototype();

		std::wcout << "#ifdef __cplusplus" << std::endl;
		std::wcout << "}" << std::endl;
		std::wcout << "#endif" << std::endl << std::endl;

		std::wcout << "#endif // " << headerDefine << std::endl;
	}

	void GenerateSource()
	{
		std::wcout << "#include <stdlib.h>" << std::endl << std::endl;
		std::wcout << "#include \"" << name << ".h\"" << std::endl << std::endl;

		GenerateStructDefinition();
		GenerateCreateDefinition();
		GenerateDeleteDefinition();
		GenerateWriteDefinition();
		GenerateReadDefinition();
		GenerateGetAccessorDefinition();
		GenerateSetAccessorDefinition();
	}

};

#endif

